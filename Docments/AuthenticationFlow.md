# Authentication flow

## 今回の認証のフロー

### CSRFトークン
POST系（データベースに変更を加えるリクエストがあった場合: POST/PUT/PATCH/DELETE）のリクエストがあった場合にそれが正規のサイトからリクエストがあったものかを検証する。

1. フロントエンドのアプリがブラウザにロードされたタイミングでCSRFトークンを発行してくれるエンドポイントにGETメソッドでアクセスし、CSRFトークンをJSONで取得する
### __csurf__
CSRFトークンを発行するエンドポイントにアクセスがあった時にset-cookieをサーバーサイドで実行しSecretをhttpOnly cookieの形でブラウザに設定する
... __Secret__ -> CSRFトークンを発行する際に使用されたSecret Key
<br>
一度ブラウザに設定されたset-cookieはその後のフロントからサーバーへのリクエストの際は自動的にクッキーがリクエストに付属する
<br>
正規のサイトでないところからcsrfトークンを発行するエンドポイントにアクセスがあった場合にはCORSのホワイトリストに正規でないサイトは登録されていないので正規でないサイトではCSRFトークンは読み取れない形になっている。

2. ユーザーがemailとpasswordを入力し、ログインボタンを押すとPOSTメソッドでemailとpasswordが送信される。<br>
サーバー側でemailとpasswordを検証し、正しい場合には __JWT__ が生成され、set-cookieをhttp Onlyの形でサーバーサイドで実行し、ブラウザに設定する。
... __httpOnly__ -> trueにしておくとブラウザのJavaScriptから読み込めないように設定<br>

3. タスクの登録 (POST: /task みたいな)
taskの内容としてtitle/descriptionが送られてくる<br>
CSRFトークンをリクエストのヘッダーに含む。
その他ロード時に発行されているSecretキーと認証時に発行されているJWTがクッキーに設定されているので自動的にリクエストに付与される。<br>
サーバー側ではCSRFトークンが妥当なものか判断するために、送られたきたSecretをクッキーから取り出してhashをかけ、送られてきたCSRFトークンとhashで計算した値が一致するかという検証をする。<br>
CSRFトークンが正しいものであった場合次はJWTの有効期限が切れていないか、JWTが正しいものかという検証をしたら実際にDBに変更をかける
<br>
<br>

## SameSite
今回のような、フロントエンドとバックエンドのドメインが違う場合にはSameSiteをnoneにしcookieの送受信を自由に行えるようにする。
そのためにはGoogle Chromeの制約でSecure属性をtrueにし、httpsで暗号化されたものとしなくてはならない。